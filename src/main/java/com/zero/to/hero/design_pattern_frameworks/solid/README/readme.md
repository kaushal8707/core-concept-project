# Single Responsibility Principle

The Single Responsibility Principle (SRP) states that a class, module, or function should have one, and only one, reason to change, 
meaning it should focus on a single, specific task or responsibility.

![img.png](img.png)

![img_1.png](img_1.png)

![img_2.png](img_2.png)

![img_3.png](img_3.png)




# Open Closed Principle

The Open-Closed Principle (OCP) states that software entities (classes, modules, functions) should be open for extension but closed for modification, 
meaning new functionality is added by adding new code, not changing old code.

![img_4.png](img_4.png)

![img_5.png](img_5.png)

![img_6.png](img_6.png)

![img_7.png](img_7.png)

![img_8.png](img_8.png)



# Liskov Substitution Principle (LSP) 

The Liskov Substitution Principle (LSP) states that objects of a superclass should be replaceable with objects of its subclasses without breaking the 
application's correctness.

![img_9.png](img_9.png)

![img_10.png](img_10.png)

![img_11.png](img_11.png)

![img_12.png](img_12.png)

![img_13.png](img_13.png)

![img_14.png](img_14.png)

![img_15.png](img_15.png)



# Interface Segregation Principle


The Interface Segregation Principle (ISP)  states that no client should be forced to depend on methods it does not use.

Instead of creating one large, "fat" interface that contains every possible action, you should split it into smaller, more specific interfaces.

![img_16.png](img_16.png)



# Dependency Inversion

The Dependency Inversion Principle (DIP), It states that high-level modules should not depend on low-level modules; 
both should depend on abstractions.

. This approach decouples code, making systems more flexible, maintainable, and easier to test.

![img_17.png](img_17.png)

![img_18.png](img_18.png)

![img_19.png](img_19.png)

![img_20.png](img_20.png)

![img_21.png](img_21.png)

![img_22.png](img_22.png)

![img_23.png](img_23.png)


